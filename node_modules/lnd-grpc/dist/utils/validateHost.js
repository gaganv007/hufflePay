"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _dns = _interopRequireDefault(require("dns"));
var _util = require("util");
var _isFQDN = _interopRequireDefault(require("validator/lib/isFQDN"));
var _isIP = _interopRequireDefault(require("validator/lib/isIP"));
var _isPort = _interopRequireDefault(require("validator/lib/isPort"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
const dnsLookup = (0, _util.promisify)(_dns.default.lookup);

/**
 * Helper function to check a hostname in the format hostname:port is valid for passing to node-grpc.
 * @param {string} host A hostname + optional port in the format [hostname]:[port?]
 * @returns {Promise<Boolean>}
 */
const validateHost = async host => {
  const createError = (msg, code) => {
    const error = new Error(msg);
    error.code = code;
    return Promise.reject(error);
  };
  try {
    const _host$split = host.split(':'),
      _host$split2 = _slicedToArray(_host$split, 2),
      lndHost = _host$split2[0],
      lndPort = _host$split2[1];

    // If the host includes a port, ensure that it is a valid.
    if (lndPort && !(0, _isPort.default)(lndPort)) {
      return createError(`${lndPort} is not a valid port`, 'LND_GRPC_HOST_ERROR');
    }
    if (lndHost.endsWith('.onion')) {
      return true;
    }

    // If the hostname starts with a number, ensure that it is a valid IP address.
    if (!(0, _isFQDN.default)(lndHost, {
      require_tld: false
    }) && !(0, _isIP.default)(lndHost)) {
      return createError(`${lndHost} is not a valid IP address or hostname`, 'LND_GRPC_HOST_ERROR');
    }
    try {
      // Do a DNS lookup to ensure that the host is reachable.
      await dnsLookup(lndHost);
      return true;
    } catch (e) {
      return createError(`${lndHost} is not accessible: ${e.message}`);
    }
  } catch (e) {
    return createError(`Host is invalid: ${e.message}`, 'LND_GRPC_HOST_ERROR');
  }
};
var _default = validateHost;
exports.default = _default;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJkbnNMb29rdXAiLCJwcm9taXNpZnkiLCJkbnMiLCJsb29rdXAiLCJ2YWxpZGF0ZUhvc3QiLCJob3N0IiwiY3JlYXRlRXJyb3IiLCJtc2ciLCJjb2RlIiwiZXJyb3IiLCJFcnJvciIsIlByb21pc2UiLCJyZWplY3QiLCJzcGxpdCIsImxuZEhvc3QiLCJsbmRQb3J0IiwiaXNQb3J0IiwiZW5kc1dpdGgiLCJpc0ZRRE4iLCJyZXF1aXJlX3RsZCIsImlzSVAiLCJlIiwibWVzc2FnZSJdLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy92YWxpZGF0ZUhvc3QuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGRucyBmcm9tICdkbnMnXG5pbXBvcnQgeyBwcm9taXNpZnkgfSBmcm9tICd1dGlsJ1xuaW1wb3J0IGlzRlFETiBmcm9tICd2YWxpZGF0b3IvbGliL2lzRlFETidcbmltcG9ydCBpc0lQIGZyb20gJ3ZhbGlkYXRvci9saWIvaXNJUCdcbmltcG9ydCBpc1BvcnQgZnJvbSAndmFsaWRhdG9yL2xpYi9pc1BvcnQnXG5cbmNvbnN0IGRuc0xvb2t1cCA9IHByb21pc2lmeShkbnMubG9va3VwKVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBjaGVjayBhIGhvc3RuYW1lIGluIHRoZSBmb3JtYXQgaG9zdG5hbWU6cG9ydCBpcyB2YWxpZCBmb3IgcGFzc2luZyB0byBub2RlLWdycGMuXG4gKiBAcGFyYW0ge3N0cmluZ30gaG9zdCBBIGhvc3RuYW1lICsgb3B0aW9uYWwgcG9ydCBpbiB0aGUgZm9ybWF0IFtob3N0bmFtZV06W3BvcnQ/XVxuICogQHJldHVybnMge1Byb21pc2U8Qm9vbGVhbj59XG4gKi9cbmNvbnN0IHZhbGlkYXRlSG9zdCA9IGFzeW5jIChob3N0KSA9PiB7XG4gIGNvbnN0IGNyZWF0ZUVycm9yID0gKG1zZywgY29kZSkgPT4ge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1zZylcbiAgICBlcnJvci5jb2RlID0gY29kZVxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcilcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgW2xuZEhvc3QsIGxuZFBvcnRdID0gaG9zdC5zcGxpdCgnOicpXG5cbiAgICAvLyBJZiB0aGUgaG9zdCBpbmNsdWRlcyBhIHBvcnQsIGVuc3VyZSB0aGF0IGl0IGlzIGEgdmFsaWQuXG4gICAgaWYgKGxuZFBvcnQgJiYgIWlzUG9ydChsbmRQb3J0KSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUVycm9yKGAke2xuZFBvcnR9IGlzIG5vdCBhIHZhbGlkIHBvcnRgLCAnTE5EX0dSUENfSE9TVF9FUlJPUicpXG4gICAgfVxuXG4gICAgaWYgKGxuZEhvc3QuZW5kc1dpdGgoJy5vbmlvbicpKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBob3N0bmFtZSBzdGFydHMgd2l0aCBhIG51bWJlciwgZW5zdXJlIHRoYXQgaXQgaXMgYSB2YWxpZCBJUCBhZGRyZXNzLlxuICAgIGlmICghaXNGUUROKGxuZEhvc3QsIHsgcmVxdWlyZV90bGQ6IGZhbHNlIH0pICYmICFpc0lQKGxuZEhvc3QpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRXJyb3IoYCR7bG5kSG9zdH0gaXMgbm90IGEgdmFsaWQgSVAgYWRkcmVzcyBvciBob3N0bmFtZWAsICdMTkRfR1JQQ19IT1NUX0VSUk9SJylcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgLy8gRG8gYSBETlMgbG9va3VwIHRvIGVuc3VyZSB0aGF0IHRoZSBob3N0IGlzIHJlYWNoYWJsZS5cbiAgICAgIGF3YWl0IGRuc0xvb2t1cChsbmRIb3N0KVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRXJyb3IoYCR7bG5kSG9zdH0gaXMgbm90IGFjY2Vzc2libGU6ICR7ZS5tZXNzYWdlfWApXG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVycm9yKGBIb3N0IGlzIGludmFsaWQ6ICR7ZS5tZXNzYWdlfWAsICdMTkRfR1JQQ19IT1NUX0VSUk9SJylcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB2YWxpZGF0ZUhvc3RcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUF5QztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUV6QyxNQUFNQSxTQUFTLEdBQUcsSUFBQUMsZUFBUyxFQUFDQyxZQUFHLENBQUNDLE1BQU0sQ0FBQzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU1DLFlBQVksR0FBRyxNQUFPQyxJQUFJLElBQUs7RUFDbkMsTUFBTUMsV0FBVyxHQUFHLENBQUNDLEdBQUcsRUFBRUMsSUFBSSxLQUFLO0lBQ2pDLE1BQU1DLEtBQUssR0FBRyxJQUFJQyxLQUFLLENBQUNILEdBQUcsQ0FBQztJQUM1QkUsS0FBSyxDQUFDRCxJQUFJLEdBQUdBLElBQUk7SUFDakIsT0FBT0csT0FBTyxDQUFDQyxNQUFNLENBQUNILEtBQUssQ0FBQztFQUM5QixDQUFDO0VBRUQsSUFBSTtJQUNGLG9CQUEyQkosSUFBSSxDQUFDUSxLQUFLLENBQUMsR0FBRyxDQUFDO01BQUE7TUFBbkNDLE9BQU87TUFBRUMsT0FBTzs7SUFFdkI7SUFDQSxJQUFJQSxPQUFPLElBQUksQ0FBQyxJQUFBQyxlQUFNLEVBQUNELE9BQU8sQ0FBQyxFQUFFO01BQy9CLE9BQU9ULFdBQVcsQ0FBRSxHQUFFUyxPQUFRLHNCQUFxQixFQUFFLHFCQUFxQixDQUFDO0lBQzdFO0lBRUEsSUFBSUQsT0FBTyxDQUFDRyxRQUFRLENBQUMsUUFBUSxDQUFDLEVBQUU7TUFDOUIsT0FBTyxJQUFJO0lBQ2I7O0lBRUE7SUFDQSxJQUFJLENBQUMsSUFBQUMsZUFBTSxFQUFDSixPQUFPLEVBQUU7TUFBRUssV0FBVyxFQUFFO0lBQU0sQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFBQyxhQUFJLEVBQUNOLE9BQU8sQ0FBQyxFQUFFO01BQzlELE9BQU9SLFdBQVcsQ0FBRSxHQUFFUSxPQUFRLHdDQUF1QyxFQUFFLHFCQUFxQixDQUFDO0lBQy9GO0lBRUEsSUFBSTtNQUNGO01BQ0EsTUFBTWQsU0FBUyxDQUFDYyxPQUFPLENBQUM7TUFDeEIsT0FBTyxJQUFJO0lBQ2IsQ0FBQyxDQUFDLE9BQU9PLENBQUMsRUFBRTtNQUNWLE9BQU9mLFdBQVcsQ0FBRSxHQUFFUSxPQUFRLHVCQUFzQk8sQ0FBQyxDQUFDQyxPQUFRLEVBQUMsQ0FBQztJQUNsRTtFQUNGLENBQUMsQ0FBQyxPQUFPRCxDQUFDLEVBQUU7SUFDVixPQUFPZixXQUFXLENBQUUsb0JBQW1CZSxDQUFDLENBQUNDLE9BQVEsRUFBQyxFQUFFLHFCQUFxQixDQUFDO0VBQzVFO0FBQ0YsQ0FBQztBQUFBLGVBRWNsQixZQUFZO0FBQUE7QUFBQSJ9