"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getProtoVersions = exports.getProtoDir = exports.getLatestProtoVersion = exports.getClosestProtoVersion = exports.default = exports.GRPC_LOWEST_VERSION = exports.GRPC_HIGHEST_STABLE_VERSION = void 0;
var _path = require("path");
var _semver = _interopRequireDefault(require("semver"));
var _debug = _interopRequireDefault(require("debug"));
var _registry = _interopRequireDefault(require("../registry"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
const debug = (0, _debug.default)('lnrpc:proto');
const GRPC_LOWEST_VERSION = '0.4.2-beta';
exports.GRPC_LOWEST_VERSION = GRPC_LOWEST_VERSION;
const GRPC_HIGHEST_STABLE_VERSION = '0.14.4-beta';

/**
 * Get the directory where rpc.proto files are stored.
 * @return {String} Directory where rpoc.proto files are stored.
 */
exports.GRPC_HIGHEST_STABLE_VERSION = GRPC_HIGHEST_STABLE_VERSION;
const getProtoDir = () => {
  return (0, _path.join)(__dirname, '..', '..', 'proto');
};

/**
 * Get a list of all rpc.proto versions that we provide.
 * @return {Promise<Array>} List of available rpc.proto versions.
 */
exports.getProtoDir = getProtoDir;
const getProtoVersions = () => {
  return Object.keys(_registry.default);
};

/**
 * Get the latest rpc.proto version that we provide.
 * @return {Promise<String>} The latest rpc.proto version that we provide.
 */
exports.getProtoVersions = getProtoVersions;
const getLatestProtoVersion = () => {
  const versions = getProtoVersions();
  return _semver.default.maxSatisfying(versions, `> ${GRPC_LOWEST_VERSION}`, {
    includePrerelease: true
  });
};

/**
 * Find the closest supported rpc.proto version based on an lnd version string.
 * @param  {[type]}  info [description]
 * @return {Promise}      [description]
 */
exports.getLatestProtoVersion = getLatestProtoVersion;
const getClosestProtoVersion = async versionString => {
  debug('Testing version string: %s', versionString);
  let _versionString$split = versionString.split(' '),
    _versionString$split2 = _slicedToArray(_versionString$split, 2),
    version = _versionString$split2[0],
    commitString = _versionString$split2[1];
  debug('Parsed version string into version: %s, commitString: %s', version, commitString);

  // If this looks like a pre-release.
  if (version.endsWith('99-beta')) {
    throw new Error(`Unsupported prerelease version: ${versionString}`);
  }
  const supportedVersions = getProtoVersions();
  debug('Searching for closest match for version %s in range: %o', version, supportedVersions);
  let match = _semver.default.maxSatisfying(supportedVersions, `<= ${version}`, {
    includePrerelease: true
  });
  debug('Determined closest rpc.proto match as: %s', match);
  return match;
};
exports.getClosestProtoVersion = getClosestProtoVersion;
var _default = {
  getProtoDir,
  getProtoVersions,
  getLatestProtoVersion,
  getClosestProtoVersion
};
exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJkZWJ1ZyIsImNyZWF0ZURlYnVnIiwiR1JQQ19MT1dFU1RfVkVSU0lPTiIsIkdSUENfSElHSEVTVF9TVEFCTEVfVkVSU0lPTiIsImdldFByb3RvRGlyIiwiam9pbiIsIl9fZGlybmFtZSIsImdldFByb3RvVmVyc2lvbnMiLCJPYmplY3QiLCJrZXlzIiwicmVnaXN0cnkiLCJnZXRMYXRlc3RQcm90b1ZlcnNpb24iLCJ2ZXJzaW9ucyIsInNlbXZlciIsIm1heFNhdGlzZnlpbmciLCJpbmNsdWRlUHJlcmVsZWFzZSIsImdldENsb3Nlc3RQcm90b1ZlcnNpb24iLCJ2ZXJzaW9uU3RyaW5nIiwic3BsaXQiLCJ2ZXJzaW9uIiwiY29tbWl0U3RyaW5nIiwiZW5kc1dpdGgiLCJFcnJvciIsInN1cHBvcnRlZFZlcnNpb25zIiwibWF0Y2giXSwic291cmNlcyI6WyIuLi8uLi9zcmMvdXRpbHMvcHJvdG8uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgam9pbiB9IGZyb20gJ3BhdGgnXG5pbXBvcnQgc2VtdmVyIGZyb20gJ3NlbXZlcidcbmltcG9ydCBjcmVhdGVEZWJ1ZyBmcm9tICdkZWJ1ZydcbmltcG9ydCByZWdpc3RyeSBmcm9tICcuLi9yZWdpc3RyeSdcblxuY29uc3QgZGVidWcgPSBjcmVhdGVEZWJ1ZygnbG5ycGM6cHJvdG8nKVxuXG5leHBvcnQgY29uc3QgR1JQQ19MT1dFU1RfVkVSU0lPTiA9ICcwLjQuMi1iZXRhJ1xuZXhwb3J0IGNvbnN0IEdSUENfSElHSEVTVF9TVEFCTEVfVkVSU0lPTiA9ICcwLjE0LjQtYmV0YSdcblxuLyoqXG4gKiBHZXQgdGhlIGRpcmVjdG9yeSB3aGVyZSBycGMucHJvdG8gZmlsZXMgYXJlIHN0b3JlZC5cbiAqIEByZXR1cm4ge1N0cmluZ30gRGlyZWN0b3J5IHdoZXJlIHJwb2MucHJvdG8gZmlsZXMgYXJlIHN0b3JlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IGdldFByb3RvRGlyID0gKCkgPT4ge1xuICByZXR1cm4gam9pbihfX2Rpcm5hbWUsICcuLicsICcuLicsICdwcm90bycpXG59XG5cbi8qKlxuICogR2V0IGEgbGlzdCBvZiBhbGwgcnBjLnByb3RvIHZlcnNpb25zIHRoYXQgd2UgcHJvdmlkZS5cbiAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXk+fSBMaXN0IG9mIGF2YWlsYWJsZSBycGMucHJvdG8gdmVyc2lvbnMuXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRQcm90b1ZlcnNpb25zID0gKCkgPT4ge1xuICByZXR1cm4gT2JqZWN0LmtleXMocmVnaXN0cnkpXG59XG5cbi8qKlxuICogR2V0IHRoZSBsYXRlc3QgcnBjLnByb3RvIHZlcnNpb24gdGhhdCB3ZSBwcm92aWRlLlxuICogQHJldHVybiB7UHJvbWlzZTxTdHJpbmc+fSBUaGUgbGF0ZXN0IHJwYy5wcm90byB2ZXJzaW9uIHRoYXQgd2UgcHJvdmlkZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGdldExhdGVzdFByb3RvVmVyc2lvbiA9ICgpID0+IHtcbiAgY29uc3QgdmVyc2lvbnMgPSBnZXRQcm90b1ZlcnNpb25zKClcbiAgcmV0dXJuIHNlbXZlci5tYXhTYXRpc2Z5aW5nKHZlcnNpb25zLCBgPiAke0dSUENfTE9XRVNUX1ZFUlNJT059YCwgeyBpbmNsdWRlUHJlcmVsZWFzZTogdHJ1ZSB9KVxufVxuXG4vKipcbiAqIEZpbmQgdGhlIGNsb3Nlc3Qgc3VwcG9ydGVkIHJwYy5wcm90byB2ZXJzaW9uIGJhc2VkIG9uIGFuIGxuZCB2ZXJzaW9uIHN0cmluZy5cbiAqIEBwYXJhbSAge1t0eXBlXX0gIGluZm8gW2Rlc2NyaXB0aW9uXVxuICogQHJldHVybiB7UHJvbWlzZX0gICAgICBbZGVzY3JpcHRpb25dXG4gKi9cbmV4cG9ydCBjb25zdCBnZXRDbG9zZXN0UHJvdG9WZXJzaW9uID0gYXN5bmMgKHZlcnNpb25TdHJpbmcpID0+IHtcbiAgZGVidWcoJ1Rlc3RpbmcgdmVyc2lvbiBzdHJpbmc6ICVzJywgdmVyc2lvblN0cmluZylcbiAgbGV0IFt2ZXJzaW9uLCBjb21taXRTdHJpbmddID0gdmVyc2lvblN0cmluZy5zcGxpdCgnICcpXG5cbiAgZGVidWcoJ1BhcnNlZCB2ZXJzaW9uIHN0cmluZyBpbnRvIHZlcnNpb246ICVzLCBjb21taXRTdHJpbmc6ICVzJywgdmVyc2lvbiwgY29tbWl0U3RyaW5nKVxuXG4gIC8vIElmIHRoaXMgbG9va3MgbGlrZSBhIHByZS1yZWxlYXNlLlxuICBpZiAodmVyc2lvbi5lbmRzV2l0aCgnOTktYmV0YScpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBwcmVyZWxlYXNlIHZlcnNpb246ICR7dmVyc2lvblN0cmluZ31gKVxuICB9XG5cbiAgY29uc3Qgc3VwcG9ydGVkVmVyc2lvbnMgPSBnZXRQcm90b1ZlcnNpb25zKClcbiAgZGVidWcoJ1NlYXJjaGluZyBmb3IgY2xvc2VzdCBtYXRjaCBmb3IgdmVyc2lvbiAlcyBpbiByYW5nZTogJW8nLCB2ZXJzaW9uLCBzdXBwb3J0ZWRWZXJzaW9ucylcblxuICBsZXQgbWF0Y2ggPSBzZW12ZXIubWF4U2F0aXNmeWluZyhzdXBwb3J0ZWRWZXJzaW9ucywgYDw9ICR7dmVyc2lvbn1gLCB7XG4gICAgaW5jbHVkZVByZXJlbGVhc2U6IHRydWUsXG4gIH0pXG5cbiAgZGVidWcoJ0RldGVybWluZWQgY2xvc2VzdCBycGMucHJvdG8gbWF0Y2ggYXM6ICVzJywgbWF0Y2gpXG5cbiAgcmV0dXJuIG1hdGNoXG59XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgZ2V0UHJvdG9EaXIsXG4gIGdldFByb3RvVmVyc2lvbnMsXG4gIGdldExhdGVzdFByb3RvVmVyc2lvbixcbiAgZ2V0Q2xvc2VzdFByb3RvVmVyc2lvbixcbn1cbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFBa0M7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFbEMsTUFBTUEsS0FBSyxHQUFHLElBQUFDLGNBQVcsRUFBQyxhQUFhLENBQUM7QUFFakMsTUFBTUMsbUJBQW1CLEdBQUcsWUFBWTtBQUFBO0FBQ3hDLE1BQU1DLDJCQUEyQixHQUFHLGFBQWE7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFJTyxNQUFNQyxXQUFXLEdBQUcsTUFBTTtFQUMvQixPQUFPLElBQUFDLFVBQUksRUFBQ0MsU0FBUyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsT0FBTyxDQUFDO0FBQzdDLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFIQTtBQUlPLE1BQU1DLGdCQUFnQixHQUFHLE1BQU07RUFDcEMsT0FBT0MsTUFBTSxDQUFDQyxJQUFJLENBQUNDLGlCQUFRLENBQUM7QUFDOUIsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUhBO0FBSU8sTUFBTUMscUJBQXFCLEdBQUcsTUFBTTtFQUN6QyxNQUFNQyxRQUFRLEdBQUdMLGdCQUFnQixFQUFFO0VBQ25DLE9BQU9NLGVBQU0sQ0FBQ0MsYUFBYSxDQUFDRixRQUFRLEVBQUcsS0FBSVYsbUJBQW9CLEVBQUMsRUFBRTtJQUFFYSxpQkFBaUIsRUFBRTtFQUFLLENBQUMsQ0FBQztBQUNoRyxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFKQTtBQUtPLE1BQU1DLHNCQUFzQixHQUFHLE1BQU9DLGFBQWEsSUFBSztFQUM3RGpCLEtBQUssQ0FBQyw0QkFBNEIsRUFBRWlCLGFBQWEsQ0FBQztFQUNsRCwyQkFBOEJBLGFBQWEsQ0FBQ0MsS0FBSyxDQUFDLEdBQUcsQ0FBQztJQUFBO0lBQWpEQyxPQUFPO0lBQUVDLFlBQVk7RUFFMUJwQixLQUFLLENBQUMsMERBQTBELEVBQUVtQixPQUFPLEVBQUVDLFlBQVksQ0FBQzs7RUFFeEY7RUFDQSxJQUFJRCxPQUFPLENBQUNFLFFBQVEsQ0FBQyxTQUFTLENBQUMsRUFBRTtJQUMvQixNQUFNLElBQUlDLEtBQUssQ0FBRSxtQ0FBa0NMLGFBQWMsRUFBQyxDQUFDO0VBQ3JFO0VBRUEsTUFBTU0saUJBQWlCLEdBQUdoQixnQkFBZ0IsRUFBRTtFQUM1Q1AsS0FBSyxDQUFDLHlEQUF5RCxFQUFFbUIsT0FBTyxFQUFFSSxpQkFBaUIsQ0FBQztFQUU1RixJQUFJQyxLQUFLLEdBQUdYLGVBQU0sQ0FBQ0MsYUFBYSxDQUFDUyxpQkFBaUIsRUFBRyxNQUFLSixPQUFRLEVBQUMsRUFBRTtJQUNuRUosaUJBQWlCLEVBQUU7RUFDckIsQ0FBQyxDQUFDO0VBRUZmLEtBQUssQ0FBQywyQ0FBMkMsRUFBRXdCLEtBQUssQ0FBQztFQUV6RCxPQUFPQSxLQUFLO0FBQ2QsQ0FBQztBQUFBO0FBQUEsZUFFYztFQUNicEIsV0FBVztFQUNYRyxnQkFBZ0I7RUFDaEJJLHFCQUFxQjtFQUNyQks7QUFDRixDQUFDO0FBQUEifQ==