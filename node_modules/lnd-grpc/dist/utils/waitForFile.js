"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _fs = _interopRequireDefault(require("fs"));
var _util = require("util");
var _debug = _interopRequireDefault(require("debug"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
const debug = (0, _debug.default)('lnrpc:util');
const stat = (0, _util.promisify)(_fs.default.stat);

/**
 * Wait for a file to exist.
 * @param {String} filepath
 */
const waitForFile = (filepath, timeout = 1000) => {
  let timeoutId;
  let intervalId;

  // This promise rejects after the timeout has passed.
  let timeoutPromise = new Promise((resolve, reject) => {
    timeoutId = setTimeout(() => {
      debug('deadline (%sms) exceeded before file (%s) was found', timeout, filepath);
      // Timout was reached, so clear all remaining timers.
      clearInterval(intervalId);
      clearTimeout(timeoutId);
      reject(new Error(`Unable to find file: ${filepath}`));
    }, timeout);
  });

  // This promise checks the filsystem every 200ms looking for the file, and resolves when the file has been found.
  let checkFileExists = new Promise(resolve => {
    let intervalId = setInterval(async () => {
      debug('waiting for file: %s', filepath);
      try {
        await stat(filepath);
        debug('found file: %s', filepath);
        // The file was found, so clear all remaining timers.
        clearInterval(intervalId);
        clearTimeout(timeoutId);
        resolve();
      } catch (e) {
        // If the file wasn't found with stat, do nothing, we will check again in 200ms.
        return;
      }
    }, 200);
  });

  // Let's race our promises.
  return Promise.race([timeoutPromise, checkFileExists]);
};
var _default = waitForFile;
exports.default = _default;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJkZWJ1ZyIsImNyZWF0ZURlYnVnIiwic3RhdCIsInByb21pc2lmeSIsImZzIiwid2FpdEZvckZpbGUiLCJmaWxlcGF0aCIsInRpbWVvdXQiLCJ0aW1lb3V0SWQiLCJpbnRlcnZhbElkIiwidGltZW91dFByb21pc2UiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsInNldFRpbWVvdXQiLCJjbGVhckludGVydmFsIiwiY2xlYXJUaW1lb3V0IiwiRXJyb3IiLCJjaGVja0ZpbGVFeGlzdHMiLCJzZXRJbnRlcnZhbCIsImUiLCJyYWNlIl0sInNvdXJjZXMiOlsiLi4vLi4vc3JjL3V0aWxzL3dhaXRGb3JGaWxlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBmcyBmcm9tICdmcydcbmltcG9ydCB7IHByb21pc2lmeSB9IGZyb20gJ3V0aWwnXG5pbXBvcnQgY3JlYXRlRGVidWcgZnJvbSAnZGVidWcnXG5cbmNvbnN0IGRlYnVnID0gY3JlYXRlRGVidWcoJ2xucnBjOnV0aWwnKVxuXG5jb25zdCBzdGF0ID0gcHJvbWlzaWZ5KGZzLnN0YXQpXG5cbi8qKlxuICogV2FpdCBmb3IgYSBmaWxlIHRvIGV4aXN0LlxuICogQHBhcmFtIHtTdHJpbmd9IGZpbGVwYXRoXG4gKi9cbmNvbnN0IHdhaXRGb3JGaWxlID0gKGZpbGVwYXRoLCB0aW1lb3V0ID0gMTAwMCkgPT4ge1xuICBsZXQgdGltZW91dElkXG4gIGxldCBpbnRlcnZhbElkXG5cbiAgLy8gVGhpcyBwcm9taXNlIHJlamVjdHMgYWZ0ZXIgdGhlIHRpbWVvdXQgaGFzIHBhc3NlZC5cbiAgbGV0IHRpbWVvdXRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgZGVidWcoJ2RlYWRsaW5lICglc21zKSBleGNlZWRlZCBiZWZvcmUgZmlsZSAoJXMpIHdhcyBmb3VuZCcsIHRpbWVvdXQsIGZpbGVwYXRoKVxuICAgICAgLy8gVGltb3V0IHdhcyByZWFjaGVkLCBzbyBjbGVhciBhbGwgcmVtYWluaW5nIHRpbWVycy5cbiAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWxJZClcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpXG4gICAgICByZWplY3QobmV3IEVycm9yKGBVbmFibGUgdG8gZmluZCBmaWxlOiAke2ZpbGVwYXRofWApKVxuICAgIH0sIHRpbWVvdXQpXG4gIH0pXG5cbiAgLy8gVGhpcyBwcm9taXNlIGNoZWNrcyB0aGUgZmlsc3lzdGVtIGV2ZXJ5IDIwMG1zIGxvb2tpbmcgZm9yIHRoZSBmaWxlLCBhbmQgcmVzb2x2ZXMgd2hlbiB0aGUgZmlsZSBoYXMgYmVlbiBmb3VuZC5cbiAgbGV0IGNoZWNrRmlsZUV4aXN0cyA9IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgbGV0IGludGVydmFsSWQgPSBzZXRJbnRlcnZhbChhc3luYyAoKSA9PiB7XG4gICAgICBkZWJ1Zygnd2FpdGluZyBmb3IgZmlsZTogJXMnLCBmaWxlcGF0aClcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHN0YXQoZmlsZXBhdGgpXG4gICAgICAgIGRlYnVnKCdmb3VuZCBmaWxlOiAlcycsIGZpbGVwYXRoKVxuICAgICAgICAvLyBUaGUgZmlsZSB3YXMgZm91bmQsIHNvIGNsZWFyIGFsbCByZW1haW5pbmcgdGltZXJzLlxuICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsSWQpXG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpXG4gICAgICAgIHJlc29sdmUoKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBJZiB0aGUgZmlsZSB3YXNuJ3QgZm91bmQgd2l0aCBzdGF0LCBkbyBub3RoaW5nLCB3ZSB3aWxsIGNoZWNrIGFnYWluIGluIDIwMG1zLlxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9LCAyMDApXG4gIH0pXG5cbiAgLy8gTGV0J3MgcmFjZSBvdXIgcHJvbWlzZXMuXG4gIHJldHVybiBQcm9taXNlLnJhY2UoW3RpbWVvdXRQcm9taXNlLCBjaGVja0ZpbGVFeGlzdHNdKVxufVxuXG5leHBvcnQgZGVmYXVsdCB3YWl0Rm9yRmlsZVxuIl0sIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFBK0I7QUFFL0IsTUFBTUEsS0FBSyxHQUFHLElBQUFDLGNBQVcsRUFBQyxZQUFZLENBQUM7QUFFdkMsTUFBTUMsSUFBSSxHQUFHLElBQUFDLGVBQVMsRUFBQ0MsV0FBRSxDQUFDRixJQUFJLENBQUM7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTUcsV0FBVyxHQUFHLENBQUNDLFFBQVEsRUFBRUMsT0FBTyxHQUFHLElBQUksS0FBSztFQUNoRCxJQUFJQyxTQUFTO0VBQ2IsSUFBSUMsVUFBVTs7RUFFZDtFQUNBLElBQUlDLGNBQWMsR0FBRyxJQUFJQyxPQUFPLENBQUMsQ0FBQ0MsT0FBTyxFQUFFQyxNQUFNLEtBQUs7SUFDcERMLFNBQVMsR0FBR00sVUFBVSxDQUFDLE1BQU07TUFDM0JkLEtBQUssQ0FBQyxxREFBcUQsRUFBRU8sT0FBTyxFQUFFRCxRQUFRLENBQUM7TUFDL0U7TUFDQVMsYUFBYSxDQUFDTixVQUFVLENBQUM7TUFDekJPLFlBQVksQ0FBQ1IsU0FBUyxDQUFDO01BQ3ZCSyxNQUFNLENBQUMsSUFBSUksS0FBSyxDQUFFLHdCQUF1QlgsUUFBUyxFQUFDLENBQUMsQ0FBQztJQUN2RCxDQUFDLEVBQUVDLE9BQU8sQ0FBQztFQUNiLENBQUMsQ0FBQzs7RUFFRjtFQUNBLElBQUlXLGVBQWUsR0FBRyxJQUFJUCxPQUFPLENBQUVDLE9BQU8sSUFBSztJQUM3QyxJQUFJSCxVQUFVLEdBQUdVLFdBQVcsQ0FBQyxZQUFZO01BQ3ZDbkIsS0FBSyxDQUFDLHNCQUFzQixFQUFFTSxRQUFRLENBQUM7TUFDdkMsSUFBSTtRQUNGLE1BQU1KLElBQUksQ0FBQ0ksUUFBUSxDQUFDO1FBQ3BCTixLQUFLLENBQUMsZ0JBQWdCLEVBQUVNLFFBQVEsQ0FBQztRQUNqQztRQUNBUyxhQUFhLENBQUNOLFVBQVUsQ0FBQztRQUN6Qk8sWUFBWSxDQUFDUixTQUFTLENBQUM7UUFDdkJJLE9BQU8sRUFBRTtNQUNYLENBQUMsQ0FBQyxPQUFPUSxDQUFDLEVBQUU7UUFDVjtRQUNBO01BQ0Y7SUFDRixDQUFDLEVBQUUsR0FBRyxDQUFDO0VBQ1QsQ0FBQyxDQUFDOztFQUVGO0VBQ0EsT0FBT1QsT0FBTyxDQUFDVSxJQUFJLENBQUMsQ0FBQ1gsY0FBYyxFQUFFUSxlQUFlLENBQUMsQ0FBQztBQUN4RCxDQUFDO0FBQUEsZUFFY2IsV0FBVztBQUFBO0FBQUEifQ==