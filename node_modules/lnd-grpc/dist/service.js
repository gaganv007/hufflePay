"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _path = require("path");
var _events = _interopRequireDefault(require("events"));
var _lodash = _interopRequireDefault(require("lodash.defaultsdeep"));
var _grpcJs = require("@grpc/grpc-js");
var _protoLoader = require("@grpc/proto-loader");
var _javascriptStateMachine = _interopRequireDefault(require("javascript-state-machine"));
var _debug = _interopRequireDefault(require("debug"));
var _utils = require("./utils");
var _registry = _interopRequireDefault(require("./registry"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
const DEFAULT_OPTIONS = {
  grpcOptions: _utils.grpcOptions,
  // Disable message size size enforcement.
  connectionOptions: {
    'grpc.max_send_message_length': -1,
    'grpc.max_receive_message_length': -1,
    'grpc.keepalive_permit_without_calls': 1
  }
};

/**
 * Base class for lnd gRPC services.
 * @extends EventEmitter
 */
let Service = /*#__PURE__*/function (_EventEmitter) {
  _inherits(Service, _EventEmitter);
  var _super = _createSuper(Service);
  function Service(serviceName, options) {
    var _this;
    _classCallCheck(this, Service);
    _this = _super.call(this);
    _this.serviceName = serviceName;
    _this.fsm = new _javascriptStateMachine.default({
      init: 'ready',
      transitions: [{
        name: 'connect',
        from: 'ready',
        to: 'connected'
      }, {
        name: 'disconnect',
        from: 'connected',
        to: 'ready'
      }],
      methods: {
        onBeforeConnect: _this.onBeforeConnect.bind(_assertThisInitialized(_this)),
        onAfterConnect: _this.onAfterConnect.bind(_assertThisInitialized(_this)),
        onBeforeDisconnect: _this.onBeforeDisconnect.bind(_assertThisInitialized(_this)),
        onAfterDisconnect: _this.onAfterDisconnect.bind(_assertThisInitialized(_this)),
        onInvalidTransition: _utils.onInvalidTransition,
        onPendingTransition: _utils.onPendingTransition
      }
    });
    _this.useMacaroon = true;
    _this.service = null;
    _this.options = (0, _lodash.default)(options, DEFAULT_OPTIONS);
    _this.debug = (0, _debug.default)(`lnrpc:service:${_this.serviceName}`);
    return _this;
  }

  // ------------------------------------
  // FSM Proxies
  // ------------------------------------
  _createClass(Service, [{
    key: "is",
    value: function is(...args) {
      return this.fsm.is(...args);
    }
  }, {
    key: "can",
    value: function can(...args) {
      return this.fsm.can(...args);
    }
  }, {
    key: "observe",
    value: function observe(...args) {
      return this.fsm.observe(...args);
    }
  }, {
    key: "state",
    get: function () {
      return this.fsm.state;
    }
  }, {
    key: "connect",
    value: function connect(...args) {
      return this.fsm.connect(...args);
    }
  }, {
    key: "disconnect",
    value: function disconnect(...args) {
      return this.fsm.disconnect(...args);
    }

    // ------------------------------------
    // FSM Callbacks
    // ------------------------------------

    /**
     * Connect to the gRPC interface.
     */
  }, {
    key: "onBeforeConnect",
    value: async function onBeforeConnect(lifecycle, options) {
      this.debug(`Connecting to ${this.serviceName} gRPC service`);
      await (0, _utils.promiseTimeout)(_utils.SERVICE_CONNECT_TIMEOUT * 1000, this.establishConnection(options), 'Connection timeout out.');
    }

    /**
     * Log successful connection.
     */
  }, {
    key: "onAfterConnect",
    value: function onAfterConnect() {
      this.debug(`Connected to ${this.serviceName} gRPC service`);
    }

    /**
     * Disconnect from the gRPC service.
     */
  }, {
    key: "onBeforeDisconnect",
    value: async function onBeforeDisconnect() {
      this.debug(`Disconnecting from ${this.serviceName} gRPC service`);
      if (this.service) {
        this.service.close();
      }
    }

    /**
     * Log successful disconnect.
     */
  }, {
    key: "onAfterDisconnect",
    value: function onAfterDisconnect() {
      this.debug(`Disconnected from ${this.serviceName} gRPC service`);
    }

    // ------------------------------------
    // Helpers
    // ------------------------------------

    /**
     * Establish a connection to the Lightning interface.
     */
  }, {
    key: "establishConnection",
    value: async function establishConnection(options = {}) {
      const opts = (0, _lodash.default)(options, this.options);
      const host = opts.host,
        cert = opts.cert,
        macaroon = opts.macaroon,
        protoDir = opts.protoDir,
        waitForCert = opts.waitForCert,
        waitForMacaroon = opts.waitForMacaroon,
        grpcOptions = opts.grpcOptions,
        connectionOptions = opts.connectionOptions,
        version = opts.version;
      try {
        // Find the most recent proto file for this service if a specific version was not requested.
        this.version = version || this.version || (0, _utils.getLatestProtoVersion)();
        const serviceDefinition = _registry.default[this.version].services.find(s => s.name === this.serviceName);
        const _serviceDefinition$pr = serviceDefinition.proto.split('/'),
          _serviceDefinition$pr2 = _slicedToArray(_serviceDefinition$pr, 2),
          protoPackage = _serviceDefinition$pr2[0],
          protoFile = _serviceDefinition$pr2[1];
        const filepath = (0, _path.join)(protoDir || (0, _utils.getProtoDir)(), this.version, protoPackage, protoFile);
        this.debug(`Establishing gRPC connection to ${this.serviceName} with proto file %s and connection options %o`, filepath, connectionOptions);

        // Load gRPC package definition as a gRPC object hierarchy.
        const packageDefinition = await (0, _protoLoader.load)(filepath, grpcOptions);
        const rpc = (0, _grpcJs.loadPackageDefinition)(packageDefinition);

        // Wait for the cert to exist (this can take some time immediately after starting lnd).
        if (waitForCert) {
          const waitTime = Number.isFinite(waitForCert) ? waitForCert : _utils.FILE_WAIT_TIMEOUT;
          await (0, _utils.waitForFile)(cert, waitTime);
        }

        // Create ssl credentials to use with the gRPC client.
        let creds = await (0, _utils.createSslCreds)(cert);

        // Add macaroon to credentials if service requires macaroons.
        if (this.useMacaroon && macaroon) {
          // Wait for the macaroon to exist (this can take some time immediately after Initializing a wallet).
          if (waitForMacaroon) {
            const waitTime = Number.isFinite(waitForMacaroon) ? waitForMacaroon : _utils.FILE_WAIT_TIMEOUT;
            await (0, _utils.waitForFile)(macaroon, waitTime);
          }
          const macaroonCreds = await (0, _utils.createMacaroonCreds)(macaroon);
          creds = _grpcJs.credentials.combineChannelCredentials(creds, macaroonCreds);
        }

        // Create a new gRPC client instance.
        const rpcService = rpc[protoPackage][this.serviceName];
        this.service = new rpcService(host, creds, connectionOptions);

        // Wait up to CONNECT_WAIT_TIMEOUT seconds for the gRPC connection to be established.
        const timeeout = (0, _utils.isTor)(host) ? _utils.CONNECT_WAIT_TIMEOUT_TOR : _utils.CONNECT_WAIT_TIMEOUT;
        await (0, _utils.promisifiedCall)(this.service, this.service.waitForReady, (0, _utils.getDeadline)(timeeout));

        // Set up helper methods to proxy service methods.
        this.wrapAsync(rpcService.service);
      } catch (e) {
        this.debug(`Unable to connect to ${this.serviceName} service`, e);
        if (this.service) {
          this.service.close();
        }
        throw e;
      }
    }
  }, {
    key: "waitForCall",
    value: async function waitForCall(method, args) {
      this.debug('Attempting to call %s.%s with args %o (will keep trying to up to %s seconds)', this.serviceName, method, args, _utils.PROBE_TIMEOUT);
      const deadline = (0, _utils.getDeadline)(_utils.PROBE_TIMEOUT);
      const checkState = async err => {
        let now = new Date().getTime();
        const isExpired = now > deadline;
        if (err && isExpired) {
          throw err;
        }
        try {
          return await this[method](args);
        } catch (error) {
          if (error.code === _grpcJs.status.UNAVAILABLE) {
            await (0, _utils.delay)(_utils.PROBE_RETRY_INTERVAL);
            return checkState(error);
          }
          throw error;
        }
      };
      return await checkState();
    }

    /**
     * Add promisified helper methods for each method in the gRPC service.
     * Inspiration from https://github.com/altangent/lnd-async
     * @param {Object} service service description used to extract apply method details
     */
  }, {
    key: "wrapAsync",
    value: function wrapAsync(service) {
      Object.values(service).forEach(method => {
        const originalName = method.originalName;
        // Do not override existing methods.
        if (this[originalName]) {
          return;
        }
        // If this method is a stream, bind it to the service instance as is.
        if (method.requestStream || method.responseStream) {
          this[originalName] = (payload = {}, options = {}) => {
            this.debug(`Calling ${this.serviceName}.${originalName} sync with: %o`, {
              payload,
              options
            });
            return this.service[originalName].bind(this.service).call(this.service, payload, options);
          };
        }
        // Otherwise, promisify and bind to the service instance.
        else {
          this[originalName] = (payload = {}, options = {}) => {
            this.debug(`Calling ${this.serviceName}.${originalName} async with: %o`, {
              payload,
              options
            });
            return (0, _utils.promisifiedCall)(this.service, this.service[originalName], payload, options);
          };
        }
      });
    }
  }]);
  return Service;
}(_events.default);
var _default = Service;
exports.default = _default;
module.exports = exports.default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJERUZBVUxUX09QVElPTlMiLCJncnBjT3B0aW9ucyIsImNvbm5lY3Rpb25PcHRpb25zIiwiU2VydmljZSIsInNlcnZpY2VOYW1lIiwib3B0aW9ucyIsImZzbSIsIlN0YXRlTWFjaGluZSIsImluaXQiLCJ0cmFuc2l0aW9ucyIsIm5hbWUiLCJmcm9tIiwidG8iLCJtZXRob2RzIiwib25CZWZvcmVDb25uZWN0IiwiYmluZCIsIm9uQWZ0ZXJDb25uZWN0Iiwib25CZWZvcmVEaXNjb25uZWN0Iiwib25BZnRlckRpc2Nvbm5lY3QiLCJvbkludmFsaWRUcmFuc2l0aW9uIiwib25QZW5kaW5nVHJhbnNpdGlvbiIsInVzZU1hY2Fyb29uIiwic2VydmljZSIsImRlZmF1bHRzRGVlcCIsImRlYnVnIiwiYXJncyIsImlzIiwiY2FuIiwib2JzZXJ2ZSIsInN0YXRlIiwiY29ubmVjdCIsImRpc2Nvbm5lY3QiLCJsaWZlY3ljbGUiLCJwcm9taXNlVGltZW91dCIsIlNFUlZJQ0VfQ09OTkVDVF9USU1FT1VUIiwiZXN0YWJsaXNoQ29ubmVjdGlvbiIsImNsb3NlIiwib3B0cyIsImhvc3QiLCJjZXJ0IiwibWFjYXJvb24iLCJwcm90b0RpciIsIndhaXRGb3JDZXJ0Iiwid2FpdEZvck1hY2Fyb29uIiwidmVyc2lvbiIsImdldExhdGVzdFByb3RvVmVyc2lvbiIsInNlcnZpY2VEZWZpbml0aW9uIiwicmVnaXN0cnkiLCJzZXJ2aWNlcyIsImZpbmQiLCJzIiwicHJvdG8iLCJzcGxpdCIsInByb3RvUGFja2FnZSIsInByb3RvRmlsZSIsImZpbGVwYXRoIiwiam9pbiIsImdldFByb3RvRGlyIiwicGFja2FnZURlZmluaXRpb24iLCJsb2FkIiwicnBjIiwibG9hZFBhY2thZ2VEZWZpbml0aW9uIiwid2FpdFRpbWUiLCJOdW1iZXIiLCJpc0Zpbml0ZSIsIkZJTEVfV0FJVF9USU1FT1VUIiwid2FpdEZvckZpbGUiLCJjcmVkcyIsImNyZWF0ZVNzbENyZWRzIiwibWFjYXJvb25DcmVkcyIsImNyZWF0ZU1hY2Fyb29uQ3JlZHMiLCJjcmVkZW50aWFscyIsImNvbWJpbmVDaGFubmVsQ3JlZGVudGlhbHMiLCJycGNTZXJ2aWNlIiwidGltZWVvdXQiLCJpc1RvciIsIkNPTk5FQ1RfV0FJVF9USU1FT1VUX1RPUiIsIkNPTk5FQ1RfV0FJVF9USU1FT1VUIiwicHJvbWlzaWZpZWRDYWxsIiwid2FpdEZvclJlYWR5IiwiZ2V0RGVhZGxpbmUiLCJ3cmFwQXN5bmMiLCJlIiwibWV0aG9kIiwiUFJPQkVfVElNRU9VVCIsImRlYWRsaW5lIiwiY2hlY2tTdGF0ZSIsImVyciIsIm5vdyIsIkRhdGUiLCJnZXRUaW1lIiwiaXNFeHBpcmVkIiwiZXJyb3IiLCJjb2RlIiwic3RhdHVzIiwiVU5BVkFJTEFCTEUiLCJkZWxheSIsIlBST0JFX1JFVFJZX0lOVEVSVkFMIiwiT2JqZWN0IiwidmFsdWVzIiwiZm9yRWFjaCIsIm9yaWdpbmFsTmFtZSIsInJlcXVlc3RTdHJlYW0iLCJyZXNwb25zZVN0cmVhbSIsInBheWxvYWQiLCJjYWxsIiwiRXZlbnRFbWl0dGVyIl0sInNvdXJjZXMiOlsiLi4vc3JjL3NlcnZpY2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgam9pbiB9IGZyb20gJ3BhdGgnXG5pbXBvcnQgRXZlbnRFbWl0dGVyIGZyb20gJ2V2ZW50cydcbmltcG9ydCBkZWZhdWx0c0RlZXAgZnJvbSAnbG9kYXNoLmRlZmF1bHRzZGVlcCdcbmltcG9ydCB7IGNyZWRlbnRpYWxzLCBsb2FkUGFja2FnZURlZmluaXRpb24sIHN0YXR1cywgTWV0YWRhdGEgfSBmcm9tICdAZ3JwYy9ncnBjLWpzJ1xuaW1wb3J0IHsgbG9hZCB9IGZyb20gJ0BncnBjL3Byb3RvLWxvYWRlcidcbmltcG9ydCBTdGF0ZU1hY2hpbmUgZnJvbSAnamF2YXNjcmlwdC1zdGF0ZS1tYWNoaW5lJ1xuaW1wb3J0IGRlYnVnIGZyb20gJ2RlYnVnJ1xuaW1wb3J0IHtcbiAgZGVsYXksXG4gIHByb21pc2lmaWVkQ2FsbCxcbiAgd2FpdEZvckZpbGUsXG4gIGdycGNPcHRpb25zLFxuICBnZXREZWFkbGluZSxcbiAgY3JlYXRlU3NsQ3JlZHMsXG4gIGNyZWF0ZU1hY2Fyb29uQ3JlZHMsXG4gIGdldExhdGVzdFByb3RvVmVyc2lvbixcbiAgZ2V0UHJvdG9EaXIsXG4gIGlzVG9yLFxuICBvbkludmFsaWRUcmFuc2l0aW9uLFxuICBwcm9taXNlVGltZW91dCxcbiAgb25QZW5kaW5nVHJhbnNpdGlvbixcbiAgRklMRV9XQUlUX1RJTUVPVVQsXG4gIFNFUlZJQ0VfQ09OTkVDVF9USU1FT1VULFxuICBQUk9CRV9USU1FT1VULFxuICBQUk9CRV9SRVRSWV9JTlRFUlZBTCxcbiAgQ09OTkVDVF9XQUlUX1RJTUVPVVQsXG4gIENPTk5FQ1RfV0FJVF9USU1FT1VUX1RPUixcbn0gZnJvbSAnLi91dGlscydcbmltcG9ydCByZWdpc3RyeSBmcm9tICcuL3JlZ2lzdHJ5J1xuXG5jb25zdCBERUZBVUxUX09QVElPTlMgPSB7XG4gIGdycGNPcHRpb25zLFxuICAvLyBEaXNhYmxlIG1lc3NhZ2Ugc2l6ZSBzaXplIGVuZm9yY2VtZW50LlxuICBjb25uZWN0aW9uT3B0aW9uczoge1xuICAgICdncnBjLm1heF9zZW5kX21lc3NhZ2VfbGVuZ3RoJzogLTEsXG4gICAgJ2dycGMubWF4X3JlY2VpdmVfbWVzc2FnZV9sZW5ndGgnOiAtMSxcbiAgICAnZ3JwYy5rZWVwYWxpdmVfcGVybWl0X3dpdGhvdXRfY2FsbHMnOiAxLFxuICB9LFxufVxuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGxuZCBnUlBDIHNlcnZpY2VzLlxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKi9cbmNsYXNzIFNlcnZpY2UgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvcihzZXJ2aWNlTmFtZSwgb3B0aW9ucykge1xuICAgIHN1cGVyKClcbiAgICB0aGlzLnNlcnZpY2VOYW1lID0gc2VydmljZU5hbWVcblxuICAgIHRoaXMuZnNtID0gbmV3IFN0YXRlTWFjaGluZSh7XG4gICAgICBpbml0OiAncmVhZHknLFxuICAgICAgdHJhbnNpdGlvbnM6IFtcbiAgICAgICAgeyBuYW1lOiAnY29ubmVjdCcsIGZyb206ICdyZWFkeScsIHRvOiAnY29ubmVjdGVkJyB9LFxuICAgICAgICB7IG5hbWU6ICdkaXNjb25uZWN0JywgZnJvbTogJ2Nvbm5lY3RlZCcsIHRvOiAncmVhZHknIH0sXG4gICAgICBdLFxuICAgICAgbWV0aG9kczoge1xuICAgICAgICBvbkJlZm9yZUNvbm5lY3Q6IHRoaXMub25CZWZvcmVDb25uZWN0LmJpbmQodGhpcyksXG4gICAgICAgIG9uQWZ0ZXJDb25uZWN0OiB0aGlzLm9uQWZ0ZXJDb25uZWN0LmJpbmQodGhpcyksXG4gICAgICAgIG9uQmVmb3JlRGlzY29ubmVjdDogdGhpcy5vbkJlZm9yZURpc2Nvbm5lY3QuYmluZCh0aGlzKSxcbiAgICAgICAgb25BZnRlckRpc2Nvbm5lY3Q6IHRoaXMub25BZnRlckRpc2Nvbm5lY3QuYmluZCh0aGlzKSxcbiAgICAgICAgb25JbnZhbGlkVHJhbnNpdGlvbixcbiAgICAgICAgb25QZW5kaW5nVHJhbnNpdGlvbixcbiAgICAgIH0sXG4gICAgfSlcblxuICAgIHRoaXMudXNlTWFjYXJvb24gPSB0cnVlXG4gICAgdGhpcy5zZXJ2aWNlID0gbnVsbFxuICAgIHRoaXMub3B0aW9ucyA9IGRlZmF1bHRzRGVlcChvcHRpb25zLCBERUZBVUxUX09QVElPTlMpXG4gICAgdGhpcy5kZWJ1ZyA9IGRlYnVnKGBsbnJwYzpzZXJ2aWNlOiR7dGhpcy5zZXJ2aWNlTmFtZX1gKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIEZTTSBQcm94aWVzXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIGlzKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5mc20uaXMoLi4uYXJncylcbiAgfVxuICBjYW4oLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLmZzbS5jYW4oLi4uYXJncylcbiAgfVxuICBvYnNlcnZlKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5mc20ub2JzZXJ2ZSguLi5hcmdzKVxuICB9XG4gIGdldCBzdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5mc20uc3RhdGVcbiAgfVxuICBjb25uZWN0KC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gdGhpcy5mc20uY29ubmVjdCguLi5hcmdzKVxuICB9XG4gIGRpc2Nvbm5lY3QoLi4uYXJncykge1xuICAgIHJldHVybiB0aGlzLmZzbS5kaXNjb25uZWN0KC4uLmFyZ3MpXG4gIH1cblxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gRlNNIENhbGxiYWNrc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvKipcbiAgICogQ29ubmVjdCB0byB0aGUgZ1JQQyBpbnRlcmZhY2UuXG4gICAqL1xuICBhc3luYyBvbkJlZm9yZUNvbm5lY3QobGlmZWN5Y2xlLCBvcHRpb25zKSB7XG4gICAgdGhpcy5kZWJ1ZyhgQ29ubmVjdGluZyB0byAke3RoaXMuc2VydmljZU5hbWV9IGdSUEMgc2VydmljZWApXG4gICAgYXdhaXQgcHJvbWlzZVRpbWVvdXQoU0VSVklDRV9DT05ORUNUX1RJTUVPVVQgKiAxMDAwLCB0aGlzLmVzdGFibGlzaENvbm5lY3Rpb24ob3B0aW9ucyksICdDb25uZWN0aW9uIHRpbWVvdXQgb3V0LicpXG4gIH1cblxuICAvKipcbiAgICogTG9nIHN1Y2Nlc3NmdWwgY29ubmVjdGlvbi5cbiAgICovXG4gIG9uQWZ0ZXJDb25uZWN0KCkge1xuICAgIHRoaXMuZGVidWcoYENvbm5lY3RlZCB0byAke3RoaXMuc2VydmljZU5hbWV9IGdSUEMgc2VydmljZWApXG4gIH1cblxuICAvKipcbiAgICogRGlzY29ubmVjdCBmcm9tIHRoZSBnUlBDIHNlcnZpY2UuXG4gICAqL1xuICBhc3luYyBvbkJlZm9yZURpc2Nvbm5lY3QoKSB7XG4gICAgdGhpcy5kZWJ1ZyhgRGlzY29ubmVjdGluZyBmcm9tICR7dGhpcy5zZXJ2aWNlTmFtZX0gZ1JQQyBzZXJ2aWNlYClcbiAgICBpZiAodGhpcy5zZXJ2aWNlKSB7XG4gICAgICB0aGlzLnNlcnZpY2UuY2xvc2UoKVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMb2cgc3VjY2Vzc2Z1bCBkaXNjb25uZWN0LlxuICAgKi9cbiAgb25BZnRlckRpc2Nvbm5lY3QoKSB7XG4gICAgdGhpcy5kZWJ1ZyhgRGlzY29ubmVjdGVkIGZyb20gJHt0aGlzLnNlcnZpY2VOYW1lfSBnUlBDIHNlcnZpY2VgKVxuICB9XG5cbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIEhlbHBlcnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLyoqXG4gICAqIEVzdGFibGlzaCBhIGNvbm5lY3Rpb24gdG8gdGhlIExpZ2h0bmluZyBpbnRlcmZhY2UuXG4gICAqL1xuICBhc3luYyBlc3RhYmxpc2hDb25uZWN0aW9uKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IG9wdHMgPSBkZWZhdWx0c0RlZXAob3B0aW9ucywgdGhpcy5vcHRpb25zKVxuICAgIGNvbnN0IHsgaG9zdCwgY2VydCwgbWFjYXJvb24sIHByb3RvRGlyLCB3YWl0Rm9yQ2VydCwgd2FpdEZvck1hY2Fyb29uLCBncnBjT3B0aW9ucywgY29ubmVjdGlvbk9wdGlvbnMsIHZlcnNpb24gfSA9XG4gICAgICBvcHRzXG5cbiAgICB0cnkge1xuICAgICAgLy8gRmluZCB0aGUgbW9zdCByZWNlbnQgcHJvdG8gZmlsZSBmb3IgdGhpcyBzZXJ2aWNlIGlmIGEgc3BlY2lmaWMgdmVyc2lvbiB3YXMgbm90IHJlcXVlc3RlZC5cbiAgICAgIHRoaXMudmVyc2lvbiA9IHZlcnNpb24gfHwgdGhpcy52ZXJzaW9uIHx8IGdldExhdGVzdFByb3RvVmVyc2lvbigpXG4gICAgICBjb25zdCBzZXJ2aWNlRGVmaW5pdGlvbiA9IHJlZ2lzdHJ5W3RoaXMudmVyc2lvbl0uc2VydmljZXMuZmluZCgocykgPT4gcy5uYW1lID09PSB0aGlzLnNlcnZpY2VOYW1lKVxuICAgICAgY29uc3QgW3Byb3RvUGFja2FnZSwgcHJvdG9GaWxlXSA9IHNlcnZpY2VEZWZpbml0aW9uLnByb3RvLnNwbGl0KCcvJylcbiAgICAgIGNvbnN0IGZpbGVwYXRoID0gam9pbihwcm90b0RpciB8fCBnZXRQcm90b0RpcigpLCB0aGlzLnZlcnNpb24sIHByb3RvUGFja2FnZSwgcHJvdG9GaWxlKVxuICAgICAgdGhpcy5kZWJ1ZyhcbiAgICAgICAgYEVzdGFibGlzaGluZyBnUlBDIGNvbm5lY3Rpb24gdG8gJHt0aGlzLnNlcnZpY2VOYW1lfSB3aXRoIHByb3RvIGZpbGUgJXMgYW5kIGNvbm5lY3Rpb24gb3B0aW9ucyAlb2AsXG4gICAgICAgIGZpbGVwYXRoLFxuICAgICAgICBjb25uZWN0aW9uT3B0aW9ucyxcbiAgICAgIClcblxuICAgICAgLy8gTG9hZCBnUlBDIHBhY2thZ2UgZGVmaW5pdGlvbiBhcyBhIGdSUEMgb2JqZWN0IGhpZXJhcmNoeS5cbiAgICAgIGNvbnN0IHBhY2thZ2VEZWZpbml0aW9uID0gYXdhaXQgbG9hZChmaWxlcGF0aCwgZ3JwY09wdGlvbnMpXG4gICAgICBjb25zdCBycGMgPSBsb2FkUGFja2FnZURlZmluaXRpb24ocGFja2FnZURlZmluaXRpb24pXG5cbiAgICAgIC8vIFdhaXQgZm9yIHRoZSBjZXJ0IHRvIGV4aXN0ICh0aGlzIGNhbiB0YWtlIHNvbWUgdGltZSBpbW1lZGlhdGVseSBhZnRlciBzdGFydGluZyBsbmQpLlxuICAgICAgaWYgKHdhaXRGb3JDZXJ0KSB7XG4gICAgICAgIGNvbnN0IHdhaXRUaW1lID0gTnVtYmVyLmlzRmluaXRlKHdhaXRGb3JDZXJ0KSA/IHdhaXRGb3JDZXJ0IDogRklMRV9XQUlUX1RJTUVPVVRcbiAgICAgICAgYXdhaXQgd2FpdEZvckZpbGUoY2VydCwgd2FpdFRpbWUpXG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBzc2wgY3JlZGVudGlhbHMgdG8gdXNlIHdpdGggdGhlIGdSUEMgY2xpZW50LlxuICAgICAgbGV0IGNyZWRzID0gYXdhaXQgY3JlYXRlU3NsQ3JlZHMoY2VydClcblxuICAgICAgLy8gQWRkIG1hY2Fyb29uIHRvIGNyZWRlbnRpYWxzIGlmIHNlcnZpY2UgcmVxdWlyZXMgbWFjYXJvb25zLlxuICAgICAgaWYgKHRoaXMudXNlTWFjYXJvb24gJiYgbWFjYXJvb24pIHtcbiAgICAgICAgLy8gV2FpdCBmb3IgdGhlIG1hY2Fyb29uIHRvIGV4aXN0ICh0aGlzIGNhbiB0YWtlIHNvbWUgdGltZSBpbW1lZGlhdGVseSBhZnRlciBJbml0aWFsaXppbmcgYSB3YWxsZXQpLlxuICAgICAgICBpZiAod2FpdEZvck1hY2Fyb29uKSB7XG4gICAgICAgICAgY29uc3Qgd2FpdFRpbWUgPSBOdW1iZXIuaXNGaW5pdGUod2FpdEZvck1hY2Fyb29uKSA/IHdhaXRGb3JNYWNhcm9vbiA6IEZJTEVfV0FJVF9USU1FT1VUXG4gICAgICAgICAgYXdhaXQgd2FpdEZvckZpbGUobWFjYXJvb24sIHdhaXRUaW1lKVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1hY2Fyb29uQ3JlZHMgPSBhd2FpdCBjcmVhdGVNYWNhcm9vbkNyZWRzKG1hY2Fyb29uKVxuICAgICAgICBjcmVkcyA9IGNyZWRlbnRpYWxzLmNvbWJpbmVDaGFubmVsQ3JlZGVudGlhbHMoY3JlZHMsIG1hY2Fyb29uQ3JlZHMpXG4gICAgICB9XG5cbiAgICAgIC8vIENyZWF0ZSBhIG5ldyBnUlBDIGNsaWVudCBpbnN0YW5jZS5cbiAgICAgIGNvbnN0IHJwY1NlcnZpY2UgPSBycGNbcHJvdG9QYWNrYWdlXVt0aGlzLnNlcnZpY2VOYW1lXVxuICAgICAgdGhpcy5zZXJ2aWNlID0gbmV3IHJwY1NlcnZpY2UoaG9zdCwgY3JlZHMsIGNvbm5lY3Rpb25PcHRpb25zKVxuXG4gICAgICAvLyBXYWl0IHVwIHRvIENPTk5FQ1RfV0FJVF9USU1FT1VUIHNlY29uZHMgZm9yIHRoZSBnUlBDIGNvbm5lY3Rpb24gdG8gYmUgZXN0YWJsaXNoZWQuXG4gICAgICBjb25zdCB0aW1lZW91dCA9IGlzVG9yKGhvc3QpID8gQ09OTkVDVF9XQUlUX1RJTUVPVVRfVE9SIDogQ09OTkVDVF9XQUlUX1RJTUVPVVRcbiAgICAgIGF3YWl0IHByb21pc2lmaWVkQ2FsbCh0aGlzLnNlcnZpY2UsIHRoaXMuc2VydmljZS53YWl0Rm9yUmVhZHksIGdldERlYWRsaW5lKHRpbWVlb3V0KSlcblxuICAgICAgLy8gU2V0IHVwIGhlbHBlciBtZXRob2RzIHRvIHByb3h5IHNlcnZpY2UgbWV0aG9kcy5cbiAgICAgIHRoaXMud3JhcEFzeW5jKHJwY1NlcnZpY2Uuc2VydmljZSlcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aGlzLmRlYnVnKGBVbmFibGUgdG8gY29ubmVjdCB0byAke3RoaXMuc2VydmljZU5hbWV9IHNlcnZpY2VgLCBlKVxuICAgICAgaWYgKHRoaXMuc2VydmljZSkge1xuICAgICAgICB0aGlzLnNlcnZpY2UuY2xvc2UoKVxuICAgICAgfVxuICAgICAgdGhyb3cgZVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIHdhaXRGb3JDYWxsKG1ldGhvZCwgYXJncykge1xuICAgIHRoaXMuZGVidWcoXG4gICAgICAnQXR0ZW1wdGluZyB0byBjYWxsICVzLiVzIHdpdGggYXJncyAlbyAod2lsbCBrZWVwIHRyeWluZyB0byB1cCB0byAlcyBzZWNvbmRzKScsXG4gICAgICB0aGlzLnNlcnZpY2VOYW1lLFxuICAgICAgbWV0aG9kLFxuICAgICAgYXJncyxcbiAgICAgIFBST0JFX1RJTUVPVVQsXG4gICAgKVxuICAgIGNvbnN0IGRlYWRsaW5lID0gZ2V0RGVhZGxpbmUoUFJPQkVfVElNRU9VVClcbiAgICBjb25zdCBjaGVja1N0YXRlID0gYXN5bmMgKGVycikgPT4ge1xuICAgICAgbGV0IG5vdyA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpXG4gICAgICBjb25zdCBpc0V4cGlyZWQgPSBub3cgPiBkZWFkbGluZVxuICAgICAgaWYgKGVyciAmJiBpc0V4cGlyZWQpIHtcbiAgICAgICAgdGhyb3cgZXJyXG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgdGhpc1ttZXRob2RdKGFyZ3MpXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gc3RhdHVzLlVOQVZBSUxBQkxFKSB7XG4gICAgICAgICAgYXdhaXQgZGVsYXkoUFJPQkVfUkVUUllfSU5URVJWQUwpXG4gICAgICAgICAgcmV0dXJuIGNoZWNrU3RhdGUoZXJyb3IpXG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3JcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGF3YWl0IGNoZWNrU3RhdGUoKVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBwcm9taXNpZmllZCBoZWxwZXIgbWV0aG9kcyBmb3IgZWFjaCBtZXRob2QgaW4gdGhlIGdSUEMgc2VydmljZS5cbiAgICogSW5zcGlyYXRpb24gZnJvbSBodHRwczovL2dpdGh1Yi5jb20vYWx0YW5nZW50L2xuZC1hc3luY1xuICAgKiBAcGFyYW0ge09iamVjdH0gc2VydmljZSBzZXJ2aWNlIGRlc2NyaXB0aW9uIHVzZWQgdG8gZXh0cmFjdCBhcHBseSBtZXRob2QgZGV0YWlsc1xuICAgKi9cbiAgd3JhcEFzeW5jKHNlcnZpY2UpIHtcbiAgICBPYmplY3QudmFsdWVzKHNlcnZpY2UpLmZvckVhY2goKG1ldGhvZCkgPT4ge1xuICAgICAgY29uc3QgeyBvcmlnaW5hbE5hbWUgfSA9IG1ldGhvZFxuICAgICAgLy8gRG8gbm90IG92ZXJyaWRlIGV4aXN0aW5nIG1ldGhvZHMuXG4gICAgICBpZiAodGhpc1tvcmlnaW5hbE5hbWVdKSB7XG4gICAgICAgIHJldHVyblxuICAgICAgfVxuICAgICAgLy8gSWYgdGhpcyBtZXRob2QgaXMgYSBzdHJlYW0sIGJpbmQgaXQgdG8gdGhlIHNlcnZpY2UgaW5zdGFuY2UgYXMgaXMuXG4gICAgICBpZiAobWV0aG9kLnJlcXVlc3RTdHJlYW0gfHwgbWV0aG9kLnJlc3BvbnNlU3RyZWFtKSB7XG4gICAgICAgIHRoaXNbb3JpZ2luYWxOYW1lXSA9IChwYXlsb2FkID0ge30sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgIHRoaXMuZGVidWcoYENhbGxpbmcgJHt0aGlzLnNlcnZpY2VOYW1lfS4ke29yaWdpbmFsTmFtZX0gc3luYyB3aXRoOiAlb2AsIHsgcGF5bG9hZCwgb3B0aW9ucyB9KVxuICAgICAgICAgIHJldHVybiB0aGlzLnNlcnZpY2Vbb3JpZ2luYWxOYW1lXS5iaW5kKHRoaXMuc2VydmljZSkuY2FsbCh0aGlzLnNlcnZpY2UsIHBheWxvYWQsIG9wdGlvbnMpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIE90aGVyd2lzZSwgcHJvbWlzaWZ5IGFuZCBiaW5kIHRvIHRoZSBzZXJ2aWNlIGluc3RhbmNlLlxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXNbb3JpZ2luYWxOYW1lXSA9IChwYXlsb2FkID0ge30sIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICAgIHRoaXMuZGVidWcoYENhbGxpbmcgJHt0aGlzLnNlcnZpY2VOYW1lfS4ke29yaWdpbmFsTmFtZX0gYXN5bmMgd2l0aDogJW9gLCB7IHBheWxvYWQsIG9wdGlvbnMgfSlcbiAgICAgICAgICByZXR1cm4gcHJvbWlzaWZpZWRDYWxsKHRoaXMuc2VydmljZSwgdGhpcy5zZXJ2aWNlW29yaWdpbmFsTmFtZV0sIHBheWxvYWQsIG9wdGlvbnMpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNlcnZpY2VcbiJdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQXFCQTtBQUFpQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRWpDLE1BQU1B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